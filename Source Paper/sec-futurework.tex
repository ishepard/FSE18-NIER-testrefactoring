%!TEX root = ./main.tex
\section{Discussion and Future Work}
\label{sec:futurework}
Automated testing has become an essential process for improving the quality of software systems~\cite{Spadini2018,Bertolino2007}. Automated tests can help ensure that production code is robust under many usage conditions and that code meets performance and security needs~\cite{Spadini2018,Bertolino2007}. Nevertheless, writing and maintaining high-quality test code is challenging and frequently considered of secondary importance~\cite{Spadini2018,Spadini,van2001refactoring}. Zaidman~\etal~\cite{Zaidman2008} investigated the
co-evolution of test and production code, showing that they grow and are modified together.
Van Deursen~\etal~\cite{van2001refactoring} described some refactoring methods 
to delete test smells, such as \textit{Inline Resource}, \textit{Setup External Resource}
or \textit{Reduce Data}.

In this paper, we analyzed what types of refactorings developers apply the most on test code, and how the maintainability of test code is related to the one on production code. We found that \textbf{Rename Method}, \textbf{Rename Class} and \textbf{Move Class} are among the most used types of refactoring. When investigating why this was the case, we found that most of the changes were due to changes in the production class, underlying the negative impact of coupling between test and production code. 

In the second research question we aimed at understanding the relation between test and production code maintainability, finding that most of the test-production class pairs were categorized as low risk. However, we found that even when production classes are being classified in higher risk categories (\eg \emph{Medium} and \emph{High}), the vast majority of test classes are still classified in the Very Low risk category. This can be attributed to the usage of testing practices (\eg Mocking~\cite{Spadini}) that ease the process of testing even for very complex classes.

As for future works, we firstly aim at introducing a more sophisticated refactoring detection tool: indeed, we noticed that some commits include several different refactorings on the same method (for example a \emph{rename} and an \emph{extract superclass}), but only one type can be recognized at the time by Refactoring-Miner. 

Furthermore we also consider to enhance our software maintainability metrics, perhaps considering several granularity levels, from system to method level. We have seen that there are already several methods proposed, each having their own flaws, we think the CK metrics are a good starting point for the assessment with possibly including the Hallstead complexity measures \cite{halstead1977elements} since they both give insight on the size and complexity of a system or piece of code.

A further area of investigation might be the relation between refactorings and maintainability. For example, does the refactoring of test code impact the maintainability of production code? And vice-versa? By analyzing this relation developers might be pushed to keep their test code in as good shape as their production code, since having higher quality test code has proven to give higher throughput and productivity \cite{athanasiou2011constructing}. 